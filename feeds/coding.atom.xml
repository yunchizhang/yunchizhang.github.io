<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Yzowledge - Coding</title><link href="https://yunchizhang.github.io/" rel="alternate"></link><link href="https://yunchizhang.github.io/feeds/coding.atom.xml" rel="self"></link><id>https://yunchizhang.github.io/</id><updated>2025-08-17T11:08:00-05:00</updated><subtitle>Knowledge and Experience</subtitle><entry><title>Synchronizing Multiple Remote Repositories</title><link href="https://yunchizhang.github.io/posts/multi_remote_repos.html" rel="alternate"></link><published>2025-08-17T11:08:00-05:00</published><updated>2025-08-17T11:08:00-05:00</updated><author><name>Yunchi Zhang</name></author><id>tag:yunchizhang.github.io,2025-08-17:/posts/multi_remote_repos.html</id><summary type="html">&lt;p&gt;How to synchronize multiple remote repositories with a local one.&lt;/p&gt;</summary><content type="html">
&lt;h2 id="multiple-remote-git-repositories"&gt;Multiple Remote Git Repositories&lt;/h2&gt;
&lt;p&gt;Synchronizing two remote Git repositories is often needed if, for example, you’re mirroring between
&lt;a href="https://github.com"&gt;GitHub&lt;/a&gt; and &lt;a href="https://gitlab.com"&gt;GitLab&lt;/a&gt;, or keeping a company’s internal Git server in sync with
a public one. There are several approaches depending on you needs. The following workflow is an example of having two
repositories (say GitHub + GitLab, or company server + external host) that both accept pushes, and developers might
push to either.&lt;/p&gt;
&lt;p&gt;That's what I'd call a &lt;em&gt;collaborative multi-remote workflow&lt;/em&gt;. The steps are:&lt;/p&gt;
&lt;h3 id="1-add-both-remotes"&gt;1. Add Both Remotes&lt;/h3&gt;
&lt;p&gt;Suppose you cloned from server A:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;clone&lt;span class="w"&gt; &lt;/span&gt;git@serverA:user/repo.git
&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;repo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now add server B:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;remote&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;serverB&lt;span class="w"&gt; &lt;/span&gt;git@serverB:user/repo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You’ll now have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;origin&lt;/strong&gt; → server A&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;serverB&lt;/strong&gt; → server B&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git remote -v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="2-keeping-both-in-sync"&gt;2. Keeping Both in Sync&lt;/h3&gt;
&lt;p&gt;Since developers may push to either, you’ll want to &lt;em&gt;fetch and merge/rebase&lt;/em&gt; changes from both regularly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Fetch all branches from both&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;fetch&lt;span class="w"&gt; &lt;/span&gt;origin
git&lt;span class="w"&gt; &lt;/span&gt;fetch&lt;span class="w"&gt; &lt;/span&gt;serverB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, update your local branch:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;main
git&lt;span class="w"&gt; &lt;/span&gt;pull&lt;span class="w"&gt; &lt;/span&gt;origin&lt;span class="w"&gt; &lt;/span&gt;main
git&lt;span class="w"&gt; &lt;/span&gt;pull&lt;span class="w"&gt; &lt;/span&gt;serverB&lt;span class="w"&gt; &lt;/span&gt;main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That merges in changes from both sides.
Then push back to both:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;push&lt;span class="w"&gt; &lt;/span&gt;origin&lt;span class="w"&gt; &lt;/span&gt;main
git&lt;span class="w"&gt; &lt;/span&gt;push&lt;span class="w"&gt; &lt;/span&gt;serverB&lt;span class="w"&gt; &lt;/span&gt;main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="3-avoiding-divergence"&gt;3. Avoiding Divergence&lt;/h3&gt;
&lt;p&gt;If people are working on feature branches, do the same process:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;feature-x
git&lt;span class="w"&gt; &lt;/span&gt;pull&lt;span class="w"&gt; &lt;/span&gt;origin&lt;span class="w"&gt; &lt;/span&gt;feature-x
git&lt;span class="w"&gt; &lt;/span&gt;pull&lt;span class="w"&gt; &lt;/span&gt;serverB&lt;span class="w"&gt; &lt;/span&gt;feature-x
git&lt;span class="w"&gt; &lt;/span&gt;push&lt;span class="w"&gt; &lt;/span&gt;origin&lt;span class="w"&gt; &lt;/span&gt;feature-x
git&lt;span class="w"&gt; &lt;/span&gt;push&lt;span class="w"&gt; &lt;/span&gt;serverB&lt;span class="w"&gt; &lt;/span&gt;feature-x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If there are conflicts, you’ll resolve them locally and push the resolved history to both remotes.&lt;/p&gt;
&lt;h3 id="4-automating-multi-push"&gt;4. Automating Multi-Push&lt;/h3&gt;
&lt;p&gt;You can configure Git so one push command updates both:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;remote&lt;span class="w"&gt; &lt;/span&gt;set-url&lt;span class="w"&gt; &lt;/span&gt;--add&lt;span class="w"&gt; &lt;/span&gt;--push&lt;span class="w"&gt; &lt;/span&gt;origin&lt;span class="w"&gt; &lt;/span&gt;git@serverA:user/repo.git
git&lt;span class="w"&gt; &lt;/span&gt;remote&lt;span class="w"&gt; &lt;/span&gt;set-url&lt;span class="w"&gt; &lt;/span&gt;--add&lt;span class="w"&gt; &lt;/span&gt;--push&lt;span class="w"&gt; &lt;/span&gt;origin&lt;span class="w"&gt; &lt;/span&gt;git@serverB:user/repo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;push&lt;span class="w"&gt; &lt;/span&gt;origin&lt;span class="w"&gt; &lt;/span&gt;main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will push to both A and B.&lt;/p&gt;
&lt;p&gt;But pulls are still separate — you’ll need to git pull from both remotes, because Git doesn’t merge multiple fetches
automatically.&lt;/p&gt;
&lt;h3 id="5-best-practices"&gt;5. Best Practices&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Decide on a primary remote for coordination (e.g., GitHub). Pull from both, but if conflicts arise, resolve and push to both.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use branch protection rules on both servers if you want consistent workflow (reviews, CI/CD, etc.).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consider a CI job or hook to auto-sync branches (e.g., GitHub Action that pushes to GitLab). That way developers only need to push once.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="Coding"></category><category term="repository"></category><category term="git"></category><category term="remote"></category></entry></feed>